/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <math.h>
#include "image.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define size 64*64

int main(void)
{
	const uint8_t *a = &image;

	// Q1 Negative of the image
	/*
	 * 0 -> 255
	 * 255 -> 0
	 */
	/*
	int x, y, z;
	x = 0b00000111;
	y = 0b11111111;
	z = x ^ y;
	*/
	uint8_t neg[size];
	for(int i = 0; i<size; i++){
		neg[i] = a[i] ^ 0b11111111;
	}

	// Q2 Thersholding by 116 (average value)
	/*
	 *		0   , value <= 116
	 * f =
	 * 		255 , value > 116
	 */
	uint8_t thresholded[size];
	int T = 116;
	for(int i = 0; i<size; i++){
			thresholded[i] = a[i]>T?0xFF:0x00;
		}

	//gc = 0xFF * (img/0xFF)^(1/gamma)
	// Q3.1 Gamma correction when gamma = 3
	/*
	 * gc3 = 0xFF * (img/0xFF)^(1/3)
	 */
	uint8_t gc3[size];
	for(int i = 0; i<size; i++){
		gc3[i] = 0xFF * pow((a[i] / 255.0), 1.0 / 3.0);

	}

	// Q3.1 Gamma correction when gamma = 1/3
	/*
	 * gc1_3 = 0xFF * (img/0xFF)^3
	*/
	uint8_t gc1_3[size];
	for(int i = 0; i<size; i++){
		gc1_3[i] = 0xFF * pow((a[i] / 255.0), 3.0);
	}

	// Q4 Piecewise linear transformations
	/*
	 * 0..T  -> 0..128
	 * T..255 -> 128..255
	 */
	uint8_t pwlt[size];
	const double f1 = 128.0 / T;
	const double f2 = (255.0 - 128.0) / (255.0 - T);
	for(int i = 0; i<size; i++){
		if(a[i] <= T){
			pwlt[i] = f1 * (double)a[i];
		}
		else{
			pwlt[i] = 128.0 + f2 * ((double)a[i] - T);
		}
	}

    /* Loop forever */
	for(;;);
}
